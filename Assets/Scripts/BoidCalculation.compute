// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateBoid

struct Boid 
{
	float3 position;
	float3 velocity;
	float3 acceleration;
};

RWStructuredBuffer<Boid> boids;

float deltaTime;

float alignmentForceFactor;
float cohesionForceFactor;
float separationForceFactor;
float boundsForceFactor;

float alignmentDistance;
float cohesionDistance;
float separationDistance;
float3 simulationCenter;
float simulationRadius;

[numthreads(1024, 1, 1)]
void UpdateBoid (uint3 id : SV_DispatchThreadID)
{
	uint boidsCount;
	uint stride;
	boids.GetDimensions(boidsCount, stride);

	float3 averagePosition = float3(0.0f, 0.0f, 0.0f);
	float3 averageVelocity = float3(0.0f, 0.0f, 0.0f);
	float3 separationForce = float3(0.0f, 0.0f, 0.0f);

	uint neighbourCount = 0;
	for (uint i = 0; i < boidsCount; i++)
	{
		float neighbourDistance = 3.0f;
 		float distance = length(boids[i].position - boids[id.x].position);
		if ( distance <= neighbourDistance)
		{
			if (distance < alignmentDistance)
				averageVelocity += boids[i].velocity;

			if (distance < cohesionDistance)
				averagePosition += boids[i].position;

			if (distance < separationDistance && id.x != i)
				separationForce += (separationDistance - distance) * (boids[id.x].position - boids[i].position) / distance;
			
			neighbourCount++;
		}
	}
	averageVelocity /= neighbourCount;
	averagePosition /= neighbourCount;

	float mass = 1.0f;

	float3 alignmentForce = alignmentForceFactor * (averageVelocity - boids[id.x].velocity) / mass;
	float3 cohesionForce = cohesionForceFactor * (averagePosition - boids[id.x].position) / mass;
	separationForce *= separationForceFactor / mass;
	float3 boundsForce = -boundsForceFactor * max(0, (length(boids[id.x].position - simulationCenter) - simulationRadius)) * (boids[id.x].position - simulationCenter) / mass;

	boids[id.x].acceleration = alignmentForce + cohesionForce + separationForce + boundsForce;
	boids[id.x].velocity += deltaTime * boids[id.x].acceleration;
	boids[id.x].position += 0.5f*boids[id.x].acceleration*deltaTime*deltaTime + boids[id.x].velocity*deltaTime;
}